<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI 25: Multi-dimensional Array Primitives</title>
  </head>

  <body>

<H1>Title</H1>

SRFI 25: Multi-dimensional Array Primitives

<H1>Author</H1>

Jussi Piitulainen

<H1>Status</H1>

This SRFI is currently in ``draft'' status. To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.  It will
remain in draft until 2002-01-11, or as amended.  to provide input on
this SRFI, please
<a href="mailto:srfi-25@srfi.schemers.org">
mail to <code>srfi-25@srfi.schemers.org</code></a>.
See <a href="http://srfi.schemers.org/srfi-list-subscribe.html">
instructions here</a> to subscribe to the list.  You can access
previous messages via
<a href="http://srfi.schemers.org/srfi-25/mail-archive/maillist.html">
the archive of the mailing list</a>.
<P>
<UL>
<LI>Draft: 2001/11/12-2002/01/11 </LI>
</UL>
</P>

<H1>Abstract</H1>

<p>
A powerful core set of procedures for creating and manipulating
heterogeneous multidimensional arrays is proposed. The design is
consistent with the rest of Scheme and independent of other container
data types. It provides easy sharing of parts of an array as other
arrays without copying, encouraging a declarative style of
programming.
</p>

<p>
The specification is based on an original contribution by Alan Bawden
in 1993.
</p>

<H1>Issues</H1>

Would the resolution now of any of the following points make the
proposal essentially more powerful or more palatable to implementors?

<ol>

<li> The name of the procedure that tells how many integers to use to
     index a given array: it used to be <code>array-rank</code> but
     somebody objected (because the rank of a matrix is something else
     altogether) and I changed it, first to <code>-dimension</code>
     and then to <code>-dimensions</code>.

<li> The optional argument to <code>make-array</code> is too lame, but
     it is consistent with <code>make-vector</code>. Should it still
     be changed to a procedure that takes indices, or should another
     procedure like <a href="tools.scm">build-array</a> be included
     for that purpose?

<li> The implementation knows about immutable arrays. Should this be
     made available to the user? Say, by adding a procedure that just
     shares an array as immutable.

<li> Other people (and not so other) have provided versions of
     <emph>row major</emph> indexing, or copying the elements into a
     vector in row major order, or copying an array with possibly
     changed shape. These are not a part of this proposal. Note that
     <a href="tools.scm">build-array</a> would serve well for simple
     copying. Row major indexing cannot rely on the elements being in
     row major order in the backing vector, so this is not really an
     efficiency issue. These seem like questions to some other surfie
     in the future (anybody).

<li> Possibly the hardest part of the design was to know when to stop.
     There is no limit to things that might be added around the
     present proposal. One hopes that nothing here needs taking out.

</ol>

<p>
(To those who commented on my last attempt to make this public, in
1999, sorry for dropping the ball then. Only "rank" has changed to
"dimensions" and row major stuff is gone; otherwise, everything is
more presentable now.)
</p>

<H1>Rationale</H1>

<p>
The main aim of this rationale is to show that the proposed design
agrees with the letter and spirit of R5RS.
</p>

<p>
The proposed arrays encourage a natural declarative programming
style. They allow sharing of most any rectangular part of an array
through a linear index mapping, without copying. But imperative style
is equally natural.
</p>

<p>
The design is consistent with the two indexed data structures of
Scheme: vectors and strings. The design makes arrays a self-contained
type. These statements are illustrated in the following paragraphs.
</p>

<p>
First, in the one-dimensional case, the arguments of the following
relevant calls match exactly.
</p>

<pre>
    (vector-set! v k o)
    (string-set! s k c)
    (array-set! a k o)
</pre>

<p>
Likewise, <code>make-array</code> matches <code>make-vector</code> and
<code>make-string</code>. An analogue to <code>vector</code>,
<code>string</code> and <code>list</code> is provided, alleviating the
lack of an external representation. Index bounds are specified as for
<code>substring</code>, lower bound included and upper bound excluded.
</p>

<p>
Array shapes are represented as arrays. Index mappings return multiple
values as multiple values.
</p>

<p>
Finally, array dimensions can begin at any index. In particular, the
choice between <code>0</code> and <code>1</code> is left to the user.
(Shapes are zero based, though.)
</p>

<H1>Specification</H1>

<p>
Arrays are heterogeneous data structures whose elements are indexed by
integer sequences of fixed length.  The length of a valid index
sequence is the <dfn>number of dimensions</dfn> of an array. The
<dfn>shape</dfn> of an array consists of bounds for each index.
</p>

<p>
The lower bound <var>b</var> and the upper bound <var>e</var> of a
dimension are exact integers with
<code>(&lt;=&nbsp;<var>b</var>&nbsp;<var>e</var>)</code>. A valid
index along the dimension is an exact integer <var>k</var> that
satisfies both
<code>(&lt;=&nbsp;<var>b</var>&nbsp;<var>k</var>)</code> and
<code>(&lt;&nbsp;<var>k</var>&nbsp;<var>e</var>)</code>. The length of
the array along the dimension is the difference
<code>(-&nbsp;<var>e</var>&nbsp;<var>b</var>)</code>. The
<dfn>size</dfn> of an array is the product of the lengths of its
dimensions.
</p>

<p>
A shape is specified as an even number of exact integers. These are
alternately the lower and upper bounds for the dimensions of an array.
</p>

<p>
The following nine procedures should be implemented.
</p>

<p>
<code>(array? <var>obj</var>)</code><br> 

Returns <samp>#t</samp> if <var>obj</var> is an array, otherwise
returns <samp>#f</samp>.
</p>

<p>
Note: there is no reasonable way to implement this procedure
accurately in R5RS; <a href="http://srfi.schemers.org/srfi-9/">SRFI
9</a> (Defining Record Types) specifies a way, and many Scheme
implementations provide something similar.
</p>

<p>
<code>(make-array <var>shape</var>)</code><br>
<code>(make-array <var>shape</var> <var>obj</var>)</code><br>

Returns a newly allocated array whose shape is given by
<var>shape</var>.  If <var>obj</var> is provided, then each element is
initialized to it. Otherwise the initial contents of each element is
unspecified.
</p>

<p>
<code>(shape <var>bound ...</var>)</code><br> 

Returns a shape. The sequence <var>bound ...</var> must consist of an
even number of exact integers that are pairwise not decreasing. Each
pair gives the lower and upper bound of a dimension. If the shape is
used to specify the dimensions of an array and <var>bound ...</var> is
the sequence <var>b0 e0 ... bk ek ...</var> of <var>n</var> pairs of
bounds, then a valid index to the array is any sequence <var>j0 ... jk
...</var> of <var>n</var> exact integers where each <var>jk</var>
satisfies <code>(&lt;=&nbsp;<var>bk</var>&nbsp;<var>jk</var>)</code>
and <code>(&lt;&nbsp;<var>jk</var>&nbsp;<var>ek</var>)</code>.
</p>

<p>
The shape of a <var>d</var>-dimensional array is a
<var>d</var>&nbsp;&times;&nbsp;<var>2</var> array where the element at
<var>k 0</var> contains the lower bound for an index along dimension
<var>k</var> and the element at <var>k 1</var> contains the
corresponding upper bound, where <var>k</var> satisfies
<code>(&lt;=&nbsp;0&nbsp;<var>k</var>)</code> and
<code>(&lt;&nbsp;<var>k</var>&nbsp;<var>d</var>)</var>.
</p>
<p>
It is an error to store anything in an element of a shape.
</p>

<p>
<code>(array <var>shape</var> <var>obj ...</var>)</code><br>

Returns a new array whose shape is given by <var>shape</var> and the
initial contents of the elements are <var>obj ...</var> in row major
order.
</p>

<p>
<code>(array-dimensions <var>array</var>)</code><br>

Returns the number of dimensions of <var>array</var>.
<pre>
    (array-dimensions
       (make-array (shape 1 2 3 4)))
</pre>

<p>
Returns <samp>2</samp>.
</p>

<p>
<code>(array-shape <var>array</var>)</code><br>

Returns the shape of <var>array</var>.
</p>

<pre>
    (= (array-dimensions a)
       (array-ref (array-shape (array-shape a)) 0 1))
</pre>

<p>
Returns <samp>#t</samp>.
</p>

<p>
Implementation note: <code>array-shape</code> has <code>(shape 0 2 0
2)</code> as a fixed point which is reached in two or three iterations
from any array.
</p>

<p>
<code>(array-ref <var>array</var> <var>k ...</var>)</code><br>

Returns the contents of the element of <var>array</var> at index
<var>k ...</var>. The sequence <var>k ...</var> must be a valid index
to <var>array</var>.
</p>

<pre>
    (array-ref (array (shape 0 2 0 3)
                  'uno 'dos 'tres
                  'cuatro 'cinco 'seis)
       1 0)
</pre>

<p>
Returns <samp>cuatro</samp>.
</p>

<p>
<code>(array-set! <var>array</var> <var>k ...</var> <var>obj</var>)</code><br>

Stores <var>obj</var> in the element of <var>array</var> at index
<var>k ...</var>. Returns an unspecified value. The sequence <var>k
...</var> must be a valid index to <var>array</var>.

<pre>
    (let ((a (make-array
                (shape 4 5 4 5 4 5))))
       (array-set! a 4 4 4 'huuhkaja)
       (array-ref a 4 4 4))
</pre>

<p>
Returns <samp>huuhkaja</samp>.
</p>

<p>
<code>(share-array <var>array</var> <var>shape</var> <var>proc</var>)</code>
<br> 

Returns a new array of shape <var>shape</var> that shares elements of
<var>array</var> through <var>proc</var>. The procedure
<var>proc</var> must implement a linear function that returns indices
of <var>array</var> when given indices of the array returned by
<code>share-array</code>.

<pre>
    (define i_4
       (let* ((i (make-array
                    (shape 0 4 0 4)
                    0))
              (d (share-array i
                    (shape 0 4)
                    (lambda (k)
                       (values k k)))))
          (do ((k 0 (+ k 1)))
              ((= k 4))
             (array-set! d k 1))
          i))
</pre>

<p>
Note: the linearity requirement for <var>proc</var> means that each
value must be a sum of multiples of the arguments passed to
<var>proc</var>; a constant term is just a special case.
</p>

<p>
Implementation note: arrays have to maintain an internal index mapping
from indices <var>k1 ... kd</var> to a single index into a backing
vector; the composition of this mapping and <var>proc</var> can be
recognised as <code>(+ n0 (* n1 <var>k1</var>) ... (* nd
<var>kd</var>))</code> by setting each index in turn to <code>1</code>
and others to <code>0</code>, and all to <code>0</code> for the
constant term; the composition can then be compiled away, together
with any complexity that the user introduced in their procedure.
</p>

<p>
This document does not specify any external representation for arrays.
This document does not specify when arrays are <code>equal?</code>.
(Indeed, R5RS <code>equal?</code> will do the wrong thing.)
</p>

<h1>Examples</h1>

<p>
The reference implementation comes with a number of files that
illustrate some ways to use the proposed system (and are very useful
in <em>testing</em> an implementation; that is their origin).
</p>

<ol>

<li> A <a href="tools.scm">tools file</a> contains a
     <code>build-array</code> for a more useful initialization of a
     new array, an <code>array-equal?</code>, a <code>times</code> to
     multiply two compatible matrices, and a <code>transpose</code>
     that can permute the dimensions of an array any which way (using
     <code>times</code>).

<li> A small <a href="test.scm">test suite</a> that uses the above
     mentioned tools.

<li> A rudimentary <a href="play.scm">display</a> procedure
     <code>play</code>, for playing around with the system.

</ol>

<H1>Implementation</H1>

<p>
A portable reference implementation is provided. It uses a minimal
error reporting mechanism that conforms to <a
href="http://srfi.schemers.org/srfi-23/">SRFI 23</a> (Error reporting
mechanism). Type disjointness requires support from the host
implementation, such as support for <a
href="http://srfi.schemers.org/srfi-9/">SRFI 9</a> (Defining Record
Types). All names not defined in this proposal are in the prefix
"<code>array:</code>", which serves as a module system.
</p>

<p>
You can get <a href="srfi-25-reference.scm">source for the reference
implementation</a> as a single file and stop reading. But there are
variations. This single file uses a vector representation that fails
disjointness. It uses procedures for indexing operations. It
represents index mapping as lists of coefficients.  Map recognition is
not optimised for any number of dimensions as that would be redundant
in this representation.
</p>

<p>
The real source comes in too many files. A working installation
consists of the following parts, each in its own file.
</p>

<ol>

<li> a <dfn>linear recogniser</dfn> of one of three types, optimised
     up to some number of dimensions,

<li> <dfn>indexing operations</dfn> to match the type, either as
     procedures or macros,

<li> a <dfn>record type definition</dfn>, either system specific for
     type disjointness, or portable as vectors, and

<li> the <a href="array.scm">main source file</a>.

</ol>

<p>
Linear recognisers are <a href="opt.scm">made by a program</a> but one
of each type is also available here, optimized for 0, 1, 2 and 3
dimensions. Choose one type: pick a recogniser with matching index
procedures <em>or</em> index macros; load <tt>op-</tt>, <tt>ix-</tt>
and <tt>as-</tt> files in this order and before <tt>array</tt>.)
</p>

<ol>

<li> A <a href="op-type1.scm">type 1 recogniser</a> represents index
     mappings as procedures that accept an optional argument.  The
     matching <a href="ix-lambda1.scm">index procedures</a> and <a
     href="ix-syntax1.scm">index macros</a> just apply the mapping to
     the arguments of <code>array-ref</code> and
     <code>array-set!</code>.

<li> A <a href="op-type2.scm">type 2 recogniser</a> represents index
     mappings as procedures that take exactly the indices. The <a
     href="ix-lambda2.scm">index procedures</a> and <a
     href="ix-syntax2.scm">index macros</a> just apply the mapping to
     the argumets of <code>array-ref</code>, but
     <code>array-set!</code> requires a dispatch for the optimised
     dimensions.

<li> A <a href="op-type3.scm">type 3 recogniser</a> represents index
     mappings as lists of coefficients. The <a
     href="ix-lambda3.scm">index procedures</a> and <a
     href="ix-syntax3.scm">index macros</a> compute the sum of
     products of coefficients and indexes in a loop on the list.
     (Optimisation depth is quite redundant. All coefficients must be
     retained in type 3.)

</ol>

<p>
Record implementations are available <a href="as-vector.scm">for
generic Scheme</a> (arrays are not disjoint from vectors), <a
href="as-srfi-9-record.scm">for SRFI 9</a> (Defining Record Types)
(<em>not tested</em>), and <a href="as-plt-struct.scm">for PLT
Scheme</a> (arrays belong to a struct type).
</p>

<p>
With the three files from above, the <a href="array.scm">main source
file</a> should work in any Scheme implementation without need of
modification. (Even (and odd) multiple values can be faked with simple
lists if they are missing.)
</p>

<p>
There is also a small set of <a href="tools.scm">useful tools</a>, and
a small <a href="test.scm">test suite</a> that uses them. Finally,
there is a procedure to <a href="play.scm">display</a> arrays, to make
it more fun and less work to play around with them.
</p>

<p>
Error checking in the implementation may be a tad expensive. The
places where it occurs are cleanly separated from the surrounding
code.
</p>

<h1>Acknowledgements</h1>

<p>
The original concept comes from a message to the Usenet newsgroup
<tt>comp.lang.scheme</tt> by Alan Bawden in 1993. A variant of that
implementation by Richard Kelsey in the Scheme 48 system was also an
influence. Apart from the origins, the main design goal has been
consistency with the core types of Scheme.
</p>

<p>
Alan Bawden and Mark K. Gardner gave useful comments at an earlier
attempt to make this specification public. (There was at least one
other. Notes have gone missing.)
</p>

<p>
The exact title of the proposal comes from a message titled "a process
that might work" by William D. Clinger to the <tt>rrrs-authors</tt>
mailing list in 1998. That appears to be a part of the past of the <a
href="http://srfi.schemers.org">SRFI process</a>.
</p>

<H1>Copyright</H1>
Copyright (C) Jussi Piitulainen (2001). All Rights Reserved. 
<p>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<p>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<p>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


    <hr>
    <address>Editor: <a
    href="mailto:srfi-editors@srfi.schemers.org">Mike Sperber</a></address>
<!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
<!-- hhmts start -->
Last modified: Wed Nov 14 10:17:37 MET 2001
<!-- hhmts end -->
  </body>
</html>
